--- 1 — Problema: dados somem ao deslogar / inconsistência front ↔ backend ↔ DB Sintoma real descrito Dados aparecem no app during session, mas desaparecem após logout/login. Às vezes CRUD “parece” funcionar (UI atualiza) mas nada aparece depois de reiniciar app. Causas prováveis 1. Front guarda dados locais (estado) sem garantir persistência no backend — ex.: salvar só no Redux/context ou AsyncStorage sem chamada POST bem-sucedida. 2. Chamadas ao backend sem await / sem checar status HTTP — front assume sucesso e já atualiza estado local. 3. Backend cria registros em memória mas não chama SaveChangesAsync() / não comita transação (EF Core) ou swallow de exceções. 4. Resposta do backend não retorna ID ou recurso criado — front não tem referência para recarregar. 5. Autenticação mal gerenciada — token expirado faz backend responder 401 e front ignora, limpando estado. 6. Ambiguidade de banco (MySQL vs Postgres) — migrations/queries usando SQL específico de uma engine quebram em outra. 7. Dados temporários no front (ex.: state-only) em vez de refetch após login. Onde procurar (arquivos/padrões) Front: src/contexts/AuthContext.js, services/api.js / src/api/index.ts, telas HomeScreen, TransactionForm, chamadas fetch/axios. Backend: Controllers (ex.: Controllers/TransactionController.cs), Services (Services/TransactionService.cs), Repositories (Repositories/TransactionRepository.cs), DbContext (ex.: TrampayDbContext.cs). Migrations: Migrations/ ou MigrationsSql/, arquivos *.sql. Config: .env, appsettings.json (strings de conexão), Program.cs (registro do DbContext). Correções concretas (passo a passo) Front-end (React Native) 1. Sempre esperar pela confirmação do backend antes de atualizar o estado local. // services/transactions.js (exemplo usando axios) export async function createTransaction(token, payload) { const res = await api.post('/transactions', payload, { headers: { Authorization: Bearer ${token} } }); if (res.status !== 201) throw new Error('Erro ao criar transação'); return res.data; // deve conter id e dados completos } // tela async function onSubmit(values) { setLoading(true); try { const created = await createTransaction(auth.token, values); // atualizar estado com created (contendo id) addTransactionToState(created); } catch (err) { showToast('Erro ao salvar: ' + err.message); } finally { setLoading(false); } } 2. Persistir somente token localmente (AsyncStorage/secureStore). Nunca persistir dados que devem vir do servidor. // AuthContext: salvar apenas token + refresh, não o objeto user completo await AsyncStorage.setItem('@trampay:token', token); 3. Refazer fetch de dados no login (on successful login -> refetch user data). // após login bem-sucedido: await AsyncStorage.setItem('@trampay:token', token); await api.setAuthToken(token); await loadInitialData(); // fetch saldo, transações, agenda Backend (.NET 8 / EF Core) 1. Garantir SaveChangesAsync() e retorno do recurso criado // Controllers/TransactionController.cs [HttpPost] [Authorize] public async Task<IActionResult> CreateTransaction([FromBody] CreateTransactionDto dto) { var userId = GetUserIdFromClaims(); var entity = _mapper.Map<Transaction>(dto); entity.UserId = userId; await _transactionService.AddAsync(entity); // service retorna entidade com Id preenchido return CreatedAtAction(nameof(GetById), new { id = entity.Id }, entity); } 2. Service/Repositório: usar transação quando várias operações de escrita estiverem juntas public async Task AddAsync(Transaction tx) { await using var transaction = await _dbContext.Database.BeginTransactionAsync(); try { _dbContext.Transactions.Add(tx); await _dbContext.SaveChangesAsync(); // outras operações relacionadas... await transaction.CommitAsync(); } catch { await transaction.RollbackAsync(); throw; } } 3. Não “engolir” exceções — log e rethrow ou retornar erro HTTP apropriado. 4. Retornar 201 Created com payload JSON contendo o ID gerado. Front depende disso. --- 2 — Problema: telas e gráficos não mostram dados corretos (Home / Fluxo Caixa / previsão) Sintomas descritos Saldo errado ou inconsistência entre soma de transações e saldo exibido. Gráfico de receitas vs despesas vazio ou com valores errados. Previsões não refletem entradas/saídas futuras. Causas prováveis 1. Conversão de datas incorreta / timezone (usar DateTime sem especificar Kind; front em America/Sao_Paulo). 2. Agrupamento SQL incorreto (GROUP BY usando texto / string de data em vez de DATE). 3. Filtros de período (start/end) enviados com horas erradas (00:00 vs timezone). 4. Backend retorna valores em centavos sem conversão no front (ou vice-versa). 5. Falha na transformação para a biblioteca do gráfico (array com labels/values mal formado). Onde procurar Endpoints: /api/reports/summary, /api/transactions, /api/reports/forecast. Front hooks: useReports, useTransactions, funções que mapeiam dados para charts. Utilitários de data: utils/date.js, helpers/dateHelper.cs. Correções concretas A — Timezone e datas (backend) Armazenar timestamps no DB em UTC; sempre converter para America/Sao_Paulo ao retornar para o cliente. // Ao salvar datas do front (assumir que front envia ISO com timezone) entity.Date = DateTime.SpecifyKind(dto.Date, DateTimeKind.Utc); await _dbContext.SaveChangesAsync(); Ao retornar para o front var dto.Date = entity.Date.ToOffset(TimeSpan.FromHours(-3)); // São Paulo -3 ou -2 dependendo DST (Melhor: usar DateTimeOffset no modelo) B — Resumo / agregações (SQL) Criar endpoint de sumarização que já devolva agregados (backend), em vez de confiar em agregação no front. -- migrations/20251114_create_reports_sp.sql (exemplo) CREATE VIEW report_daily AS SELECT user_id, DATE(CONVERT_TZ(date_utc, '+00:00','-03:00')) as date_sp, SUM(CASE WHEN type='income' THEN amount ELSE 0 END) as total_income, SUM(CASE WHEN type='expense' THEN amount ELSE 0 END) as total_expense FROM transactions GROUP BY user_id, DATE(CONVERT_TZ(date_utc, '+00:00','-03:00')); (Adaptar para MySQL/POSTGRES: AT TIME ZONE/CONVERT_TZ) C — Conformidade de unidades monetárias Decidir: armazenar DECIMAL(15,2) no DB e enviar JSON number com decimal. Se armazenar em centavos, padronizar (inteiro) e converter antes de enviar. D — Transformação para charts (front) Função utilitária: function transformForChart(transactions) { // retorna [{ label: 'Jan', income: 1000, expense: 500 }, ...] const map = {}; transactions.forEach(tx => { const day = formatToBrazilDay(tx.date); // usar timezone local map[day] = map[day] || { income: 0, expense: 0 }; if (tx.type === 'income') map[day].income += tx.amount; else map[day].expense += tx.amount; }); return Object.keys(map).map(k => ({ label: k, ...map[k] })); } --- 3 — Problema: Agenda não persiste / notificações falham / navegação entre meses inconsistente Sintomas Evento cadastrado some após voltar à tela. Notificações não disparam no horário ou disparam no horário errado. Navegação entre meses reinicia ou não carrega eventos. Causas prováveis 1. Datas salvas sem timezone / sem converter para UTC. 2. Falta de endpoint para CRUD de eventos; front usa AsyncStorage local. 3. Uso incorreto do Expo Notifications (ou não uso de Permissions / requestPermissionsAsync). 4. Listagem paginada incorreta para mudança de mês (não passa start/end corretos). Onde procurar Front: screens/AgendaScreen.js, services/agenda.js, components/Calendar. Backend: Controllers/EventsController.cs, Models/Event.cs. Correções concretas Backend Modelo Event com DateTimeOffset public class Event { public long Id { get; set; } public long UserId { get; set; } public string Title { get; set; } public DateTimeOffset StartAt { get; set; } public DateTimeOffset EndAt { get; set; } public bool IsNotified { get; set; } } Endpoints POST /api/events (auth) — retorna 201 com o evento salvo. GET /api/events?start=2025-11-01&end=2025-11-30 — retorna eventos no período. Front (Expo) 1. Agendamento local de notificações import * as Notifications from 'expo-notifications'; import * as Permissions from 'expo-permissions'; await Permissions.requestAsync(Permissions.NOTIFICATIONS); const scheduleNotification = async (event) => { const triggerDate = new Date(event.startAt); // converter corretamente para local await Notifications.scheduleNotificationAsync({ content: { title: event.title, body: 'Evento hoje' }, trigger: { date: triggerDate } }); // agendar também 1 hora antes: const hourBefore = new Date(triggerDate.getTime() - 60 * 60 * 1000); await Notifications.scheduleNotificationAsync({ content: { title: event.title, body: '1 hora para o evento' }, trigger: { date: hourBefore } }); }; 2. Sincronizar evento salvo no backend com notificações locais Após POST /api/events bem-sucedido, chamar scheduleNotification(createdEvent). 3. Navegação entre meses Ao mudar mês, calcular start e end no client com timezone local e chamar GET /api/events?start=...&end=.... --- 4 — Problema: PRO flow travando / estado inconsistente Sintomas Usuário ativa PRO mas app fica com estado indefinido. Cancelamentos retornam a tela antiga mas sem atualizar backend. Botão de ativar/desativar trava quando clicar rapidamente. Causas prováveis 1. Processo de ativação não é atômico: várias escritas sem transação. 2. Front atualiza estado local antes do backend confirmar. 3. Race conditions: múltiplos cliques disparam múltiplas requisições. 4. Backend retorna 200 mas não persiste (SaveChangesAsync faltando). Correções concretas Backend Service que gere inscrição PRO com transação public async Task ActivatePro(long userId, ProActivationDto dto) { await using var tx = await _dbContext.Database.BeginTransactionAsync(); try { var sub = new Subscription { UserId = userId, Active = true, ... }; _dbContext.Subscriptions.Add(sub); await _dbContext.SaveChangesAsync(); await tx.CommitAsync(); } catch { await tx.RollbackAsync(); throw; } } Endpoint: POST /api/pro/activate retorna 200 { active: true, expiresAt: "..." } Front 1. Desabilitar botão enquanto request pendente <Button disabled={loading} onPress={onActivate}>Ativar PRO</Button> 2. Debounce / ignore clicks rápidos 3. Atualizar estado somente após resposta do backend (não antes) --- 5 — Problema: Tela IA com erros de modelo/token e visual não integrado Sintomas Erros “invalid token” ou “model not found”. Mensagens de erro mostradas como stack trace. UI da IA não segue paleta do app. Causas prováveis 1. Chaves no projeto, mas código usa variável errada / path diferente (ex.: OPENAI_KEY vs OPENAI_API_KEY). 2. Falha em validar token antes de chamar provider. 3. Lógica de retry ausente; erros retornam raw ao front. 4. Front não trata erros (exibe exception.message). Onde procurar Backend: Services/OpenAiService.cs, Controllers/AiController.cs. Front: screens/AiScreen.js, services/ai.js. Correções concretas Backend 1. Validar que variável está presente no appsettings.json / env var key = _config["OpenAI:ApiKey"]; if (string.IsNullOrEmpty(key)) return BadRequest(new { error = "AI key missing" }); 2. Implementar retry/backoff (Polly) e tratar erros amigavelmente var policy = Policy .Handle<HttpRequestException>() .WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(Math.Pow(2,i))); await policy.ExecuteAsync(async () => { // chamada ao provider }); 3. Endpoint exemplo POST /api/ai/chat — body: { prompt: "..." }, auth: JWT Response: { id: "...", model: "gpt-4o-mini", reply: "..." } ou { error: "Mensagem amigável" } Front 1. Validar token localmente e exibir modal claro se faltar. 2. Mostrar loader, esconder stack traces e usar toasts: try { setLoading(true); const res = await api.post('/ai/chat', { prompt }); setMessages(prev => [...prev, { from: 'ai', text: res.reply }]); } catch (err) { showToast('Erro ao acessar IA: ' + (err.response?.data?.error ?? err.message)); } finally { setLoading(false); } 3. UI: barra fixa de prompt, histórico em bolhas, botão limpar conversa, e mostrar qual modelo está sendo usado no topo. --- 6 — Problema: Endpoints faltando / DTOs divergentes / status codes errados Sintomas Front espera 201 e backend retorna 200. Front espera id no body e backend não retorna. DTOs no front (TypeScript interfaces) não batem com modelos do backend. Correções concretas 1. Padronizar contratos: definir DTOs no backend e gerar clients (OpenAPI/Swagger) ou manter documentação atualizada. 2. Exemplo de endpoint corrigido POST /api/transactions Auth: Bearer JWT Request: { "date": "2025-11-14T12:00:00-03:00", "amount": 100.50, "type": "expense", "categoryId": 3, "notes": "Taxi" } Response (201): { "id": 12345, "userId": 42, "date": "2025-11-14T15:00:00Z", "amount": 100.50, "type": "expense", "categoryId": 3, "notes": "Taxi", "createdAt": "2025-11-14T15:00:00Z" } Errors: 401 Unauthorized — token ausente/expirado 400 BadRequest — validação DTO (mensagens detalhadas) 500 Internal — erro inesperado (não expor stack trace) 3. Validações: usar FluentValidation (C#) para DTOs, retornar 400 com lista de erros. --- 7 — Problema: Migrations faltantes / inconsistentes entre ambientes (MySQL x Postgres) Sintomas dotnet ef database update falha. Diferença de types (ex.: SERIAL vs AUTO_INCREMENT). Campos faltando (e.g., subscriptions.active ou events.startAt). Correções concretas 1. Inspecionar appsettings.json e migrations — garantir provider correto (UseMySql vs UseNpgsql) no Program.cs. 2. Migration template exemplo (UP + DOWN) -- Migrations/20251114_AddSubscriptionsTable.sql (MySQL example) -- UP CREATE TABLE subscriptions ( id BIGINT AUTO_INCREMENT PRIMARY KEY, user_id BIGINT NOT NULL, active BOOLEAN NOT NULL DEFAULT FALSE, started_at DATETIME(6), expires_at DATETIME(6), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, CONSTRAINT fk_sub_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ); -- DOWN DROP TABLE IF EXISTS subscriptions; (For Postgres, use SERIAL / bigserial and TIMESTAMP WITH TIME ZONE) 3. Adicionar coluna DateTimeOffset para eventos: ALTER TABLE events ADD COLUMN start_at TIMESTAMP WITH TIME ZONE; 4. Seed minimal (exemplo SQL para testes) INSERT INTO categories (id, user_id, name, type) VALUES (1, 1, 'Salário', 'income'), (2, 1, 'Alimentação', 'expense'); --- 8 — Problema: Autenticação / JWT inconsistências (userId não usado / expiração) Sintomas Backend não recebe userId válido (claims). Requisições que exigem userId retornam 403 ou vazias. Causas Middleware JWT sem mapear claim correto (ex.: sub vs id). Token salvo no front sem prefixo Bearer . Token expirado e front não trata refresh. Correção concreta 1. Validação no backend private long GetUserId() { var claim = User.FindFirst(ClaimTypes.NameIdentifier) ?? User.FindFirst("sub"); if (claim == null) throw new UnauthorizedAccessException(); return long.Parse(claim.Value); } 2. Front: sempre enviar header axios.defaults.headers.common['Authorization'] = Bearer ${token}; 3. Adicionar refresh token flow (se aplicável). Se não tiver, ao detectar 401, redirecionar para login. --- 9 — Problema: chamadas API com baseURL/headers errados no front Sintomas Chamadas apontam para localhost errado no Expo (usar IP da máquina), ou http vs https. Headers faltando (Content-Type, Authorization). Correção concreta 1. Configurar baseURL dinamicamente (usar .env ou Constants.manifest.extra.API_BASE_URL) import Constants from 'expo-constants'; const API_BASE_URL = Constants.manifest.extra?.API_BASE_URL ?? 'http://10.0.2.2:5000'; 2. Axios instance const api = axios.create({ baseURL: API_BASE_URL }); api.interceptors.request.use(async config => { const token = await AsyncStorage.getItem('@trampay:token'); if (token) config.headers.Authorization = Bearer ${token}; return config; }); --- 10 — Problema: código swallow-exceptions / logs insuficientes Sintoma Erro silencioso — UI mostra sucesso, mas no backend SaveChanges falha. Correção concreta Adicionar logs estruturados (Serilog) e retornar erros amigáveis ao front. catch(Exception ex) { _logger.LogError(ex, "Erro ao criar transação para user {UserId}", userId); return StatusCode(500, new { error = "Erro interno, tente novamente" }); } --- 11 — Onde normalmente estão as chaves secretas (e como tratá-las) Você disse que todas as chaves secretas já estão no projeto. Tipicamente elas aparecem em: appsettings.json ou appsettings.Development.json (ou appsettings.Production.json) — backend .env ou app.config — front (Expo: app.json / app.config.js com extra) secrets.json ou arquivos pessoais que não devem ser commitados Ao exibir arquivos para auditoria: substituir valores reais por placeholders do tipo: OPENAI_API_KEY = "<INSIRA_SUA_OPENAI_KEY_AQUI>" DATABASE_URL = "<INSIRA_SUA_STRING_DE_CONEXAO_AQUI>" STRIPE_KEY = "<INSIRA_SUA_STRIPE_KEY_AQUI>" E indicar o caminho exato onde re-inserir localmente (ex.: appsettings.Development.json para backend; app.json/.env para frontend). --- 12 — Checklist operacional para aplicar correções (ordem sugerida) 1. Localizar e fixar DbContext e Program.cs (provider correto). 2. Rodar dotnet ef migrations list e comparar migrations com models; criar migrations faltantes. 3. Corrigir controllers/services para sempre await SaveChangesAsync() e retornar CreatedAtAction. 4. Padronizar uso de DateTimeOffset. 5. Expor endpoints de relatório/summary (aggregations) para alimentar gráficos. 6. No front: centralizar api (axios), garantir Authorization header e só persistir token. 7. Atualizar AuthContext: persistir só token; fetch inicial após login. 8. No front: trocar atualizações de estado que são “optimistic” por confirmação server-first, ou implementar rollback. 9. Agenda: implementar endpoints e agendar notificações locais após sucesso do POST. 10. PRO: ativação via endpoint transacional; front desabilita botão até finalização. 11. IA: validar chave antes do chamado; usar retry/backoff e retornar mensagens amigáveis. 12. Adicionar logging e tratar erros. --- 13 — Exemplos rápidos de arquivos/trechos para aplicar (copiar/colar) Exemplo: Controller (Transaction) — C# (.NET 8) Use isso de referência e ajuste nomes do seu projeto: === ARQUIVO: backend/Controllers/TransactionController.cs === using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Mvc; [ApiController] [Route("api/[controller]")] public class TransactionController : ControllerBase { private readonly ITransactionService _service; public TransactionController(ITransactionService service) { _service = service; } [HttpPost] [Authorize] public async Task<IActionResult> Create([FromBody] CreateTransactionDto dto) { var userId = long.Parse(User.FindFirst("sub")?.Value ?? "0"); var created = await _service.CreateTransactionAsync(userId, dto); return CreatedAtAction(nameof(GetById), new { id = created.Id }, created); } [HttpGet("{id}")] [Authorize] public async Task<IActionResult> GetById(long id) { var userId = long.Parse(User.FindFirst("sub")?.Value ?? "0"); var tx = await _service.GetByIdAsync(userId, id); if (tx == null) return NotFound(); return Ok(tx); } } Exemplo: Service com transação === ARQUIVO: backend/Services/TransactionService.cs === public async Task<Transaction> CreateTransactionAsync(long userId, CreateTransactionDto dto) { var txEntity = _mapper.Map<Transaction>(dto); txEntity.UserId = userId; await using var transaction = await _db.Database.BeginTransactionAsync(); try { _db.Transactions.Add(txEntity); await _db.SaveChangesAsync(); // possíveis outros writes... await transaction.CommitAsync(); return txEntity; } catch { await transaction.RollbackAsync(); throw; } } Exemplo: Axios instance (front) === ARQUIVO: src/services/api.js === import axios from 'axios'; import AsyncStorage from '@react-native-async-storage/async-storage'; const API_BASE_URL = process.env.API_BASE_URL || 'http://10.0.2.2:5000'; const api = axios.create({ baseURL: API_BASE_URL }); api.interceptors.request.use(async config => { const token = await AsyncStorage.getItem('@trampay:token'); if (token) config.headers.Authorization = Bearer ${token}; return config; }, error => Promise.reject(error)); export default api; --- 14 — Mensagens de erro e UX (boa prática) Nunca mostrar stack trace ao usuário. Exibir mensagens curtas: “Não foi possível salvar. Verifique sua conexão.” Para IA: mensagem específica se token inválido: “Chave de IA inválida — verifique configuração”. --- 15 — Observações finais e próximos passos imediatos (prioritários) 1. Implementar SaveChangesAsync() em todos os services que fazem escrita; revisar controllers que não fazem await. — alta prioridade. 2. Padronizar armazenamento de data usando DateTimeOffset no backend e UTC no DB; converter para America/Sao_Paulo no front. 3. Centralizar instancia axios/cliente HTTP no front e assegurar Authorization header. 4. Criar endpoints agregados (reports) no backend para alimentar gráficos de forma confiável. 5. Sincronizar agenda: persistir no backend e só então agendar notificações locais no device. 6. Corrigir fluxo PRO: transação no backend + desabilitar/feedback no front. 7. Corrigir fluxo IA: validar keys, retry/backoff e mensagens amigáveis.